using System;
using System.Data;
using Microsoft.Data.SqlClient;

namespace DataAccess
{
    public class SqlHelper
    {
        /// <summary>
        /// Executes a query via SqlCommand (returns no resultset) against the databse specified in the connection string, using the provided parameters with values
        /// </summary>
        /// <param name="connection">A valid connection string for a SqlConnection</param>
        /// <param name="commandText">The query</param>
        /// <param name="commandParameters">The array of SqlParameter to send for the query (In the case of a parameterized query)</param>
        /// <returns>The number of affected rows, by the command</returns>
        public static int ExecuteNonQuery(SqlConnection connection, string commandText, SqlParameter[] commandParameters)
        {
            var cmd = connection.CreateCommand();
            PrepareCommand(cmd, connection, null, CommandType.Text, commandText, commandParameters);
            var val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }
        /// <summary>
        /// Executes a query via SqlCommand (returns no resultset) against the databse specified in the connection string, using the provided parameters with values
        /// </summary>
        /// <param name="connection">A valid connection string for a SqlConnection</param>
        /// <param name="commandText">The query</param>
        /// <returns>The number of affected rows, by the command</returns>
        public static int ExecuteNonQuery(SqlConnection connection, string commandText)
        {
            var cmd = connection.CreateCommand();
            PrepareCommand(cmd, connection, null, CommandType.Text, commandText);
            var val = cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
            return val;
        }

        /// <summary>
        /// Execute a SqlCommand (that returns no resultset) against the specified SqlConnection 
        /// using the provided parameters.
        /// </summary>
        /// <remarks>
        /// e.g.:  
        ///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
        /// </remarks>
        /// <param name="connection">A valid SqlConnection</param>
        /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="commandText">The stored procedure name or T-SQL command</param>
        /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
        /// <returns>An int representing the number of rows affected by the command</returns>
        public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText, SqlParameter[] commandParameters)
        {
            var cmd = connection.CreateCommand();
            using (connection)
            {
                PrepareCommand(cmd, connection, null, commandType, commandText, commandParameters);
                var val = cmd.ExecuteNonQuery();
                cmd.Parameters.Clear();
                return val;
            }
        }
        /// <summary>
        /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
        /// using the provided parameters.
        /// </summary>
        /// <param name="connection">A valid SqlConnection</param>
        /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="commandText">The stored procedure name or T-SQL command</param>
        /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
        /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
        public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText, SqlParameter[] commandParameters)
        {
            var cmd = connection.CreateCommand();
            PrepareCommand(cmd, connection, null, commandType, commandText, commandParameters);
            var rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
            return rdr;
        }

        /// <summary>
        /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
        /// </summary>
        /// <param name="connection">A valid SqlConnection</param>
        /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="commandText">The stored procedure name or T-SQL command</param>
        /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
        public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText)
        {
            var cmd = connection.CreateCommand();
            PrepareCommand(cmd, connection, null, commandType, commandText);
            var rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
            return rdr;
        }
        
        /// <summary>
        /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the database specified in 
        /// the connection using the provided parameter values.  This method will query the database to discover the parameters for the 
        /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
        /// </summary>
        /// <remarks>
        /// This method provides no access to output parameters or the stored procedure's return value parameter.
        /// 
        /// e.g.:  
        ///  int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
        /// </remarks>
        /// <param name="connection">A valid SqlConnection</param>
        /// /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="commandText">The stored procedure name or T-SQL command</param>
        /// <param name="commandParameters">An array of objects to be assigned as the input values of the stored procedure</param>
        /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        public static object ExecuteScalar(SqlConnection connection, CommandType commandType, string commandText, SqlParameter[] commandParameters)
        {
            var cmd = connection.CreateCommand();
            PrepareCommand(cmd, connection, null, commandType, commandText, commandParameters);
            var val = cmd.ExecuteScalar();
            cmd.Parameters.Clear();
            return val;
        }

        private static void PrepareCommand(SqlCommand cmd, SqlConnection connection, SqlTransaction trans, CommandType commandType, string commandText, SqlParameter[] commandParameters)
        {
            if (connection.State != ConnectionState.Open)
            {
                connection.Open();
            }
            cmd.Connection = connection;
            cmd.CommandText = commandText;
            if (trans != null)
            {
                cmd.Transaction = trans;
            }
            cmd.CommandType = commandType;
            //attach the command parameters if they are provided
            if (commandParameters != null)
            {
                AttachParameters(cmd, commandParameters);
            }
        }

        private static void PrepareCommand(SqlCommand cmd, SqlConnection connection, SqlTransaction trans, CommandType commandType, string commandText)
        {
            if (connection.State != ConnectionState.Open)
            {
                connection.Open();
            }
            cmd.Connection = connection;
            cmd.CommandText = commandText;
            if (trans != null)
            {
                cmd.Transaction = trans;
            }
            cmd.CommandType = commandType;
        }
        private static void AttachParameters(SqlCommand command, SqlParameter[] commandParameters)
        {
            foreach (var p in commandParameters)
            {
                //check for derived output value with no value assigned
                if ((p.Direction == ParameterDirection.InputOutput) && (p.Value == null))
                {
                    p.Value = DBNull.Value;
                }
                command.Parameters.Add(p);
            }
        }
    }
}
